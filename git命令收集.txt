一、本地git命令：


git每一个commit命令内部会生成一个commit对象，一个commit对象指向当前工作空间(文件状态)对应生成的blob对象树(一个文件或者一个目录对应一个blob对象，blob包含基于当前文件或目录生成的校验和)。
git分支实际上类似于指向一个commit对象的指针(分支指针)。HEAD也是一个指针，指向当前所在的本地分支对应的分支指针。


1.git branch 
	新建一个分支。
	实际上是在当前HEAD指针指向的分支指针所指向的commit对象上新生成一个分支指针，指向当前commit对象。

	-d  删除分支。如果该分支没有完全被其他分支合并，删除会失败
	--merged  查看已经合并的分支，不带*标识的分支可以用-d删除
	--no-merged  查看未合并或完全合并的分支



2.git checkout
	切换工作分支。
	实际上是改变HEAD指针所指向的分支指针。

	-- file_name  把该文件从暂存区移除，并撤销对该文件的修改(git reset只会移出暂存区，不会撤销文件的修改)



3.git add
	把需要commit的文件加入暂存区。
	实际上是重新计算需要提交文件和目录的校验和，生成对应的blob对象，并加入暂存区。



4.git reset
	把加入到暂存区的文件从暂存区移除。



5.git commit
	提交暂存区。
	实际上是针对暂存区重新生成一个blob对象树(当前工作空间的快照)，并生成一个commit对象指向该blob对象树，并移动当前分支指针指向该commit对象。

	--amend  补提交。不会重新生成commit对象，会把当前暂存区再做一次提交，修改上次commit对象指向的blob树。也可以用于覆盖上次提交信息



6.git merge
	合并分支。
	实际上是基于当前需要合并的blob树，对比有改动的文件，进行git add加入暂存区，再进行git commit生成一个新的commit对象(git merge可以类似看成对比后git add + git commit)。

	如果需要合并的commit对象是当前执行合并的commit对象的上游(类似单链)，则进行FastForward(简单合并，并把分支指针向前移动，指向新的commit对象)。
	如果需要合并的commit对象和当前执行合并的commit对象在更早开始分叉，则选取需要合并的commit对象，执行合并的commit对象以及两者交汇的分叉commit对象对比合并，生成新commit对象。如果中途出
现冲突，发生冲突的文件不会进行git add，也不会进行git commit重新生成commit对象，git status查看冲突文件，修改完冲突后手动git add冲突文件，并手动git commit。



7.git stash
	储藏与清理工作目录的脏的状态(有修改的跟踪文件与暂存改动)，默认只会储藏修改的跟踪文件和暂存文件，不会储藏未跟踪文件(可以通过选项改变该行为)。
	通过栈实现。如果工作目录没有处于clean状态(有跟踪文件修改或者git add对应的暂存区不为空)，这个时候切换目录，不但在当前目录的修改会丢失，而且可能会引起冲突(修改了已跟踪的文件)，而此时
又不想去使用git commit来提交(工作只进行了一半)，就可以用这个命令保存工作状态到栈中，以后进行恢复。

	--include-untracked 或 -u  同时储藏未跟踪文件
	--keep-index  不会储藏git add命令已暂存的文件
	--patch  不会储藏任何修改过的文件，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中
	--all  储藏整个工作目录



8.git stash list
	显示当前储藏栈的情况，该储藏栈是全局的，意味着任何分支指针指向的commit对象都可以应用该储藏栈，这个情况下需要排除冲突。



9.git stash apply
	恢复之前储藏在栈中的工作目录的脏的状态，默认不会恢复之前储藏的git add命令已暂存的文件(可以通过选项改变该行为)。

	--index  同时恢复之前储藏的git add命令已暂存的文件



10.git stash branch
	相当于git branch + git checkout + git stash。



11.git rebase
	效果与git merge相同，只是组织合并的形式不同，最后都会重新生成commit对象(git rebase根据rebase分支的情况可能会生成多个commit对象的情况)。
	git rebase会把当前分支上所有的commit对象与他需要rebase的分支的共同的commit对象(分叉处)做比较，提取相应的修改并存为临时文件，然后将分支指针指向rebase的分支，依次做git commit。

	--onto 可以指定特定分支且与其他分支不重合的部分进行rebase



12.git clean
	清理工作目录的脏的状态(有修改的跟踪文件与暂存改动)并丢弃，会移除没有忽略(任何与 .gitiignore 或其他忽略文件中的模式匹配的文件)的未跟踪文件，因此要小心使用该命令，非特殊目的
最好使用stash。

	-f  强制移除
	-d  同时移除空的子目录
	-n  clean前显示有哪些文件会被移除
	-x  移除未跟踪文件，无论是否忽略
	-i  交互式clean
	


13.git status
	查看当前工作分支的状态。




二、远程git命令：


git远程引用是对远程仓库的引用（指针），包括分支、标签等等。
远程跟踪分支是远程分支状态的引用。相当于一个存在与本地，但是记录远程commit对象的分支指针，不能自己移动，只能在每次git fetch后更新指向的commit对象。


1.git remote add
	增加一个远程引用。
	实际上是在本地创建一个指向远程仓库的指针。


2.git fetch
	拉取远程分支。
	实际上是在本地更新远程仓库对应分支上的commit对象，以及把本地远程分支的引用(分支指针)更新到与远程仓库一致，但不会进行git merge操作。


3.git pull
	拉取远程分支，并进行合并。
	简单来看就是git fetch后把本地对应分支指针指向的commit对象和本地远程分支指针指向的commit对象进行git merge(远程commit对象已经被git fetch更新下来)。





Reading From: https://git-scm.com/book/en/v2

