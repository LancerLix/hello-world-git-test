一、本地git命令：


git每一个commit命令内部会生成一个commit对象，一个commit对象指向当前工作空间(文件状态)对应生成的blob对象树(一个文件或者一个目录对应一个blob对象，blob包含基于当前文件或目录生成的校验和)。
git分支实际上类似于指向一个commit对象的指针(分支指针)。HEAD也是一个指针，指向当前所在的本地分支对应的分支指针。


1.git branch 
	新建一个分支。
	实际上是在当前HEAD指针指向的分支指针所指向的commit对象上新生成一个分支指针，指向当前commit对象。



2.git checkout
	切换工作分支。
	实际上是改变HEAD指针所指向的分支指针。



3.git add
	把需要commit的文件加入暂存区。
	实际上是重新计算需要提交文件和目录的校验和，生成对应的blob对象，并加入暂存区。



4.git commit
	提交暂存区。
	实际上是针对暂存区重新生成一个blob对象树(当前工作空间的快照)，并生成一个commit对象指向该blob对象树，并移动当前分支指针指向该commit对象。



5.git merge
	合并分支。
	实际上是基于当前需要合并的blob树，对比有改动的文件，进行git add加入暂存区，再进行git commit生成一个新的commit对象(git merge可以类似看成对比后git add + git commit)。

	如果需要合并的commit对象是当前执行合并的commit对象的上游(类似单链)，则进行FastForward(简单合并，并把分支指针向前移动，指向新的commit对象)。
	如果需要合并的commit对象和当前执行合并的commit对象在更早开始分叉，则选取需要合并的commit对象，执行合并的commit对象以及两者交汇的分叉commit对象对比合并，生成新commit对象。如果中途出
现冲突，发生冲突的文件不会进行git add，也不会进行git commit重新生成commit对象，git status查看冲突文件，修改完冲突后手动git add冲突文件，并手动git commit。



6.git stash
	储藏恢复与清理工作目录的脏的状态(有修改的跟踪文件与暂存改动)。
	通过栈实现。如果工作目录没有处于clean状态(有跟踪文件修改或者git add对应的暂存区不为空)，这个时候切换目录，不但在当前目录的修改会丢失，而且可能会引起冲突(修改了已跟踪的文件)，而此时又不想去使用
git commit来提交(工作只进行了一半)，就可以用这个命令保存工作状态到栈中，以后进行恢复。
	


7.git status
	查看当前工作分支的状态。




二、远程git命令：


git远程引用是对远程仓库的引用（指针），包括分支、标签等等。
远程跟踪分支是远程分支状态的引用。相当于一个存在与本地，但是记录远程commit对象的分支指针，不能自己移动，只能在每次git fetch后更新指向的commit对象。


1.git remote add
	增加一个远程引用。
	实际上是在本地创建一个指向远程仓库的指针。


2.git fetch
	拉取远程分支。
	实际上是在本地更新远程仓库对应分支上的commit对象，以及把本地远程分支的引用(分支指针)更新到与远程仓库一致，但不会进行git merge操作。


3.git pull
	拉取远程分支，并进行合并。
	简单来看就是git fetch后把本地对应分支指针指向的commit对象和本地远程分支指针指向的commit对象进行git merge(远程commit对象已经被git fetch更新下来)。





Reading From: https://git-scm.com/book/en/v2

